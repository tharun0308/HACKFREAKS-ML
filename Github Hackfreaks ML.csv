chmod,+x,make_project.sh
./make_project.sh
set,-e
"ROOT=""AgenticReasoning_Hackathon"""
rm,-rf,"""$ROOT"""
mkdir,-p,"""$ROOT"""
cat,>,"""$ROOT/README.md""",<<'README'
*Saptang,Labs,â€”,Machine,Learning,Challenge*
This,repository,contains,a,modular,Agentic,Reasoning,System,designed,to,decompose,and,solve,logic/math,"questions,"
select,&,run,appropriate,tools,"(calculator,",symbolic,"solver,",code,"executor),",verify,"results,",and,produce
transparent,reasoning,traces,alongside,final,predictions.
Quickstart:
1.,Create,python,environment,(python,3.9+).
2.,Install,dependencies:
pip,install,-r,requirements.txt
3.,Run,inference,on,test,data:
python,src/agent/main.py,--input,sample_data/test.csv,--output,submission_output.csv
README
cat,>,"""$ROOT/requirements.txt""",<<'REQ'
sympy>=1.8
pandas
numpy
python-dotenv
REQ
cat,>,"""$ROOT/technical_report.md""",<<'REP'
Agent,pipeline:,Decomposer,->,Tool,Selector,->,Executor,->,Verifier,->,Tracer.
Rule-based,heuristics,for,decomposition;,SymPy,for,symbolic,solving;,safe,arithmetic,eval,for,calculator.
Submit,submission_output.csv;,evaluate,Macro,F1,and,trace,quality.
REP
mkdir,-p,"""$ROOT/sample_data"""
cat,>,"""$ROOT/sample_data/train.csv""",<<'TRAIN'
"id,question,answer"
"1,If",a+b=10,and,a-b=2,find,"a,6"
"2,Compute","13*7,91"
"3,How",many,ways,to,choose,2,from,"5?,10"
"4,Simplify",(x**2,-,"1)/(x-1),x+1"
TRAIN
cat,>,"""$ROOT/sample_data/test.csv""",<<'TEST'
"id,question"
"101,If",x+y=5,and,x-y=1,find,x
"102,Compute",15*4
"103,How",many,ways,to,choose,3,from,6?
"104,Solve",for,x:,2*x+3=11
"105,Simplify",(y**2-4)/(y-2)
TEST
cat,>,"""$ROOT/output_template.csv""",<<'OUT'
"id,prediction,reasoning_trace"
OUT
mkdir,-p,"""$ROOT/src/agent/tools"""
cat,>,"""$ROOT/src/agent/main.py""",<<'MAIN'
import,"argparse,",pandas,as,"pd,",json
from,agent,import,agent,as,agent_module
def,main():
parser,=,argparse.ArgumentParser()
"parser.add_argument(""--input"",","required=True,","help=""input",test,csv,"path"")"
"parser.add_argument(""--output"",","required=True,","help=""output",csv,"path"")"
args,=,parser.parse_args()
df,=,pd.read_csv(args.input)
agent,=,agent_module.Agent()
outputs,=,[]
for,"_,",row,in,df.iterrows():
qid,=,row['id']
question,=,row['question']
"pred,",trace,=,agent.solve(question)
"outputs.append({""id"":","qid,","""prediction"":","pred,","""reasoning_trace"":",trace})
outdf,=,pd.DataFrame(outputs)
"outdf.to_csv(args.output,",index=False)
"print(f""Wrote",{args.output},with,{len(outputs)},"rows."")"
if,_name_,==,'_main_':
main()
MAIN
cat,>,"""$ROOT/src/agent/agent.py""",<<'AGENT'
import,"re,","json,",time
from,agent.tools.calculator,import,Calculator
from,agent.tools.symbolic_solver,import,SymbolicSolver
from,agent.tools.executor,import,Executor
class,Agent:
def,_init_(self):
self.calc,=,Calculator()
self.sym,=,SymbolicSolver()
self.exec,=,Executor()
def,"solve(self,",question_text):
start,=,time.time()
subtasks,=,self.decompose(question_text)
trace_steps,=,[]
final_answer,=,None
for,"i,",sub,in,enumerate(subtasks):
tool,=,self.select_tool(sub)
"trace_steps.append(f""Subtask",{i+1}:,{sub['type']},->,"{sub['text']}"")"
if,tool,==,'sympy':
res,=,self.sym.solve(sub['text'])
"trace_steps.append(f""",->,sympy,result:,"{res}"")"
elif,tool,==,'calc':
res,=,self.calc.eval(sub['text'])
"trace_steps.append(f""",->,calc,result:,"{res}"")"
elif,tool,==,'exec':
res,=,self.exec.run(sub['text'])
"trace_steps.append(f""",->,exec,result:,"{res}"")"
else:
res,=,'UNSOLVED'
"trace_steps.append(f""",->,no,tool,"available"")"
verified,=,self.verify(res)
"trace_steps.append(f""",->,verified:,"{verified}"")"
final_answer,=,res,if,final_answer,is,None,else,final_answer
duration,=,time.time(),-,start
trace,=,"json.dumps({""question"":question_text,","""duration_s"":round(duration,3),","""steps"":","trace_steps},",ensure_ascii=False)
return,"str(final_answer),",trace
def,"decompose(self,",q):
q_lower,=,q.strip()
subtasks,=,[]
if,"re.search(r'\\bfind\\b.*\\b[a-zA-Z]\\b',",q_lower),and,'=',in,q_lower:
"subtasks.append({'type':'equation_system','text':q})"
return,subtasks
if,re.search(r'\\bcompute\\b|\\bcalculate\\b|\\bwhat,"is\\b',","q_lower,",re.I),and,"re.search(r'\\d',",q_lower):
expr,=,"re.sub(r'[^0-9\\+\\-\\*\\/\\(\\)\\^\\,\\s]','',",q)
expr,=,"expr.replace('^','')"
"subtasks.append({'type':'arithmetic','text':expr})"
return,subtasks
if,re.search(r'how,many,"ways|choose|combination|permutation',",q_lower):
"subtasks.append({'type':'combinatorics','text':q})"
return,subtasks
if,'solve',in,q_lower,and,'=',in,q_lower:
"subtasks.append({'type':'equation','text':q})"
return,subtasks
"subtasks.append({'type':'arithmetic','text':q})"
return,subtasks
def,"select_tool(self,",subtask):
t,=,subtask['type']
if,t,in,"('equation','equation_system'):"
return,'sympy'
if,t,in,"('arithmetic','combinatorics'):"
return,'calc'
return,'exec'
def,"verify(self,",res):
try:
float(res)
return,True
except,Exception:
return,bool(res)
AGENT
cat,>,"""$ROOT/src/agent/tools/calculator.py""",<<'CALC'
import,"ast,","math,",re
ALLOWED_NAMES,=,{k:,"getattr(math,",k),for,k,in,dir(math),if,not,k.startswith('_')}
"ALLOWED_NAMES.update({'abs':abs,","'round':round,","'min':min,",'max':max})
class,Calculator:
def,_init_(self):
pass
def,"eval(self,",expr_text):
expr,=,"re.sub(r'[^0-9\+\-\\/\(\)\.\,\s\\*]',","'',",str(expr_text))
expr,=,"expr.replace('^','')"
try:
node,=,"ast.parse(expr,",mode='eval')
return,str(self._eval(node.body))
except,Exception,as,e:
return,f'ERROR:,{e}'
def,"_eval(self,",node):
import,ast
if,"isinstance(node,",ast.Num):
return,node.n
if,"isinstance(node,",ast.BinOp):
left,=,self._eval(node.left)
right,=,self._eval(node.right)
if,"isinstance(node.op,",ast.Add):
return,left,+,right
if,"isinstance(node.op,",ast.Sub):
return,left,-,right
if,"isinstance(node.op,",ast.Mult):
return,left,*,right
if,"isinstance(node.op,",ast.Div):
return,left,/,right
if,"isinstance(node.op,",ast.Pow):
return,left,**,right
if,"isinstance(node,",ast.UnaryOp):
val,=,self._eval(node.operand)
if,"isinstance(node.op,",ast.UAdd):,return,+val
if,"isinstance(node.op,",ast.USub):,return,-val
if,"isinstance(node,",ast.Call):
func,=,node.func.id
args,=,[self._eval(a),for,a,in,node.args]
if,func,in,ALLOWED_NAMES:
return,ALLOWED_NAMES[func](*args)
raise,ValueError('Unsupported,expression')
CALC
cat,>,"""$ROOT/src/agent/tools/symbolic_solver.py""",<<'SYM'
from,sympy,import,"symbols,","Eq,","solve,","sympify,",simplify
import,re
class,SymbolicSolver:
def,_init_(self):
pass
def,"solve(self,",text):
text,=,text.strip()
eqs,=,"re.findall(r'([a-zA-Z0-9\+\-\\/\s\^\(\)=]+=[^,\n\.])',",text)
if,not,eqs,and,'=',in,text:
parts,=,text.split(':')[-1],if,':',in,text,else,text
eqs,=,[p.strip(),for,p,in,parts.split('and'),if,'=',in,p]
try:
vars,=,"set(re.findall(r'\b([a-zA-Z])\b',",text))
syms,=,symbols(list(vars))
if,len(eqs)==1:
"left,right",=,eqs[0].split('=')
expr,=,sympify(left),-,sympify(right)
sol,=,"solve(expr,",list(syms))
if,sol:
return,str(sol[0])
elif,len(eqs),>,1:
syms_list,=,list(syms)
sympy_eqs,=,[]
for,e,in,eqs:
"l,r",=,e.split('=')
"sympy_eqs.append(Eq(sympify(l),",sympify(r)))
sol,=,"solve(sympy_eqs,","syms_list,",dict=True)
return,str(sol)
if,'simplify',in,text,or,'/',in,text,and,'(',in,text:
expr_text,=,"re.sub(r'.*simplify','',","text,",flags=re.I)
expr,=,sympify(expr_text)
return,str(simplify(expr))
except,Exception,as,e:
return,f'ERROR_SYM:,{e}'
return,'NO_SOLUTION'
SYM
cat,>,"""$ROOT/src/agent/tools/executor.py""",<<'EXEC'
class,Executor:
def,_init_(self):
pass
def,"run(self,",code_text):
try:
allowed_builtins,=,{'_builtins_':{}}
result,=,"eval(code_text,","{""math"":_import_('math')},",allowed_builtins)
return,str(result)
except,Exception,as,e:
return,f'EXEC_ERROR:,{e}'
EXEC
cat,>,"""$ROOT/.gitignore""",<<'GIT'
venv/
_pycache_/
*.pyc
*.zip
GIT
"ZIPNAME=""AgenticReasoning_Submission.zip"""
rm,-f,"""$ZIPNAME"""
cd,"""$ROOT"""
zip,-r,"""../$ZIPNAME""",./*
cd,..
echo,"""Created",$ZIPNAME,in,current,"directory."""